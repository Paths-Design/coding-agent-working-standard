#!/usr/bin/env node

/**
 * God Object Detector
 * 
 * Checks for god objects (large files) in staged files only.
 * This script is automatically generated by CAWS scaffold.
 * 
 * @author @darianrosebrook
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Configuration
const CONFIG = {
  godObjectThresholds: {
    warning: 1750,
    critical: 2000,
  },
};

// Collect staged Rust files only
function collectStagedRustFiles() {
  try {
    // Get staged files
    const stagedFiles = execSync("git diff --cached --name-only", {
      encoding: "utf8",
    })
      .trim()
      .split("\n")
      .filter((file) => file.trim() !== "");

    // Filter for Rust files
    const rustFiles = stagedFiles.filter((file) => file.endsWith(".rs"));

    // Convert to absolute paths
    const RUST_FILES = [];
    for (const file of rustFiles) {
      const fullPath = path.resolve(file);
      if (fs.existsSync(fullPath)) {
        RUST_FILES.push(fullPath);
      }
    }

    console.log(`ðŸ“ Found ${rustFiles.length} staged Rust files to check`);
    return RUST_FILES;
  } catch (error) {
    console.warn(`âš ï¸  Could not get staged files: ${error.message}`);
    return [];
  }
}

// Check for god objects
function checkGodObjects() {
  const RUST_FILES = collectStagedRustFiles();
  
  if (RUST_FILES.length === 0) {
    console.log("âœ… No staged Rust files to check for god objects");
    return { violations: [], warnings: [] };
  }

  const violations = [];
  const warnings = [];

  for (const filePath of RUST_FILES) {
    try {
      const content = fs.readFileSync(filePath, 'utf8');
      const lineCount = content.split('\n').length;
      const relativePath = path.relative(process.cwd(), filePath);

      if (lineCount >= CONFIG.godObjectThresholds.critical) {
        violations.push({
          file: relativePath,
          lines: lineCount,
          message: `CRITICAL: ${lineCount} LOC exceeds god object threshold (${CONFIG.godObjectThresholds.critical}+ LOC)`
        });
      } else if (lineCount >= CONFIG.godObjectThresholds.warning) {
        warnings.push({
          file: relativePath,
          lines: lineCount,
          message: `WARNING: ${lineCount} LOC approaches god object territory (${CONFIG.godObjectThresholds.warning}+ LOC)`
        });
      }
    } catch (error) {
      console.warn(`âš ï¸  Could not analyze ${filePath}: ${error.message}`);
    }
  }

  return { violations, warnings };
}

// Check for god object regression
function checkGodObjectRegression() {
  const RUST_FILES = collectStagedRustFiles();
  
  if (RUST_FILES.length === 0) {
    return { regression: false };
  }

  // This is a simplified check - in a real implementation,
  // you might want to compare against previous commits
  const results = checkGodObjects();
  
  return {
    regression: results.violations.length > 0,
    violations: results.violations,
    warnings: results.warnings
  };
}

// Main execution
function main() {
  console.log("ðŸ—ï¸  Checking god objects...");
  
  const results = checkGodObjects();
  
  if (results.violations.length > 0) {
    console.log("   âŒ God object violations detected:");
    results.violations.forEach(violation => {
      console.log(`      ${violation.file}: ${violation.message}`);
    });
    process.exit(1);
  } else {
    console.log("   âœ… No blocking god object violations");
  }
  
  if (results.warnings.length > 0) {
    console.log("   âš ï¸  God object warnings:");
    results.warnings.forEach(warning => {
      console.log(`      ${warning.file}: ${warning.message}`);
    });
  }
}

// Run if called directly
if (require.main === module) {
  main();
}

module.exports = {
  checkGodObjects,
  checkGodObjectRegression,
  collectStagedRustFiles,
};
