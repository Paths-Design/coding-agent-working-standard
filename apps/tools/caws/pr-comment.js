#!/usr/bin/env node

/**
 * CAWS PR Comment Bot - Generates structured PR summary comments
 *
 * Usage: node pr-comment.js [pr-number]
 * Output: GitHub-flavored markdown comment
 */
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

function getWorkingSpec() {
  try {
    const specPath = path.join(process.cwd(), '.caws', 'working-spec.yaml');
    if (!fs.existsSync(specPath)) {
      return null;
    }

    const yaml = require('js-yaml');
    return yaml.load(fs.readFileSync(specPath, 'utf8'));
  } catch (error) {
    console.error('Error reading working spec:', error.message);
    return null;
  }
}

function getTestResults() {
  const results = {
    coverage: 'unknown',
    mutation: 'unknown',
    contracts: 'unknown',
    a11y: 'unknown',
    perf: 'unknown',
  };

  try {
    // Try to read test artifacts
    if (fs.existsSync('coverage/lcov.info')) {
      const lcov = fs.readFileSync('coverage/lcov.info', 'utf8');
      const lines = lcov.match(/LF:(\d+)/);
      const functions = lcov.match(/FNF:(\d+)/);
      const branches = lcov.match(/BRF:(\d+)/);
      const hitLines = lcov.match(/LH:(\d+)/);

      if (lines && hitLines) {
        const coverage = ((parseInt(hitLines[1]) / parseInt(lines[1])) * 100).toFixed(1);
        results.coverage = `${coverage}%`;
      }
    }

    if (fs.existsSync('.stryker/mutation.json')) {
      const mutation = JSON.parse(fs.readFileSync('.stryker/mutation.json', 'utf8'));
      results.mutation = `${mutation.metrics.mutationScore}%`;
    }

    // Check for contract test results
    if (fs.existsSync('test-results/contract.json')) {
      const contracts = JSON.parse(fs.readFileSync('test-results/contract.json', 'utf8'));
      results.contracts = contracts.passed ? '✅' : '❌';
    }

    // Check for a11y test results
    if (fs.existsSync('test-results/a11y.json')) {
      const a11y = JSON.parse(fs.readFileSync('test-results/a11y.json', 'utf8'));
      results.a11y = a11y.passed ? '✅' : '❌';
    }

    // Check for perf budget results
    if (fs.existsSync('test-results/perf.json')) {
      const perf = JSON.parse(fs.readFileSync('test-results/perf.json', 'utf8'));
      results.perf = perf.passed ? '✅' : '❌';
    }
  } catch (error) {
    console.error('Error reading test results:', error.message);
  }

  return results;
}

function getChangeMetrics() {
  try {
    const output = execSync('git diff --stat origin/main...', { encoding: 'utf8' });
    const lines = output.trim().split('\n');
    const lastLine = lines[lines.length - 1];

    // Parse "X files changed, Y insertions(+), Z deletions(-)"
    const match = lastLine.match(
      /(\d+) files? changed, (\d+) insertions?\(\+\), (\d+) deletions?\(-\)/
    );
    if (match) {
      return {
        files: parseInt(match[1]),
        additions: parseInt(match[2]),
        deletions: parseInt(match[3]),
        total: parseInt(match[2]) + parseInt(match[3]),
      };
    }
  } catch (error) {
    console.error('Error getting git diff stats:', error.message);
  }

  return { files: 0, additions: 0, deletions: 0, total: 0 };
}

function generatePRComment() {
  const spec = getWorkingSpec();
  const tests = getTestResults();
  const metrics = getChangeMetrics();

  if (!spec) {
    return `# CAWS PR Summary (auto)

⚠️ **No working spec found**
Please run \`npm run caws:start\` to initialize your change specification.

---
*Generated by CAWS PR Bot*
`;
  }

  const mode = spec.mode || 'unknown';
  const tier = spec.tier || 2;
  const title = spec.title || 'Untitled change';
  const id = spec.id || 'unknown';

  // Determine tier requirements
  const tierMinCoverage = tier === 1 ? 0.9 : tier === 2 ? 0.8 : 0.7;
  const tierMinMutation = tier === 1 ? 0.7 : tier === 2 ? 0.5 : 0.3;

  const coverageStatus =
    tests.coverage !== 'unknown'
      ? parseFloat(tests.coverage) >= tierMinCoverage
        ? '✅'
        : '❌'
      : '⏳';
  const mutationStatus =
    tests.mutation !== 'unknown'
      ? parseFloat(tests.mutation) >= tierMinMutation
        ? '✅'
        : '❌'
      : '⏳';

  const comment = `# CAWS PR Summary (auto)

## Change Details
- **ID**: \`${id}\`
- **Mode**: \`${mode}\`
- **Risk Tier**: ${tier} ${tier === 1 ? '🔴' : tier === 2 ? '🟡' : '🟢'}
- **Title**: ${title}

## Quality Gates
| Gate | Status | Value | Required |
|------|--------|-------|----------|
| **Coverage** | ${coverageStatus} | ${tests.coverage} | ≥ ${Math.round(tierMinCoverage * 100)}% |
| **Mutation** | ${mutationStatus} | ${tests.mutation} | ≥ ${Math.round(tierMinMutation * 100)}% |
| **Contracts** | ${tests.contracts === 'unknown' ? '⏳' : tests.contracts} | - | ✅ |
| **A11y** | ${tests.a11y === 'unknown' ? '⏳' : tests.a11y} | - | ✅ |
| **Perf** | ${tests.perf === 'unknown' ? '⏳' : tests.perf} | - | ✅ |

## Scope & Budget
| Metric | Value | Budget | Status |
|--------|-------|--------|--------|
| **Files** | ${metrics.files} | ${spec.change_budget?.max_files || 25} | ${metrics.files <= (spec.change_budget?.max_files || 25) ? '✅' : '❌'} |
| **LOC** | ${metrics.total} | ${spec.change_budget?.max_loc || 1000} | ${metrics.total <= (spec.change_budget?.max_loc || 1000) ? '✅' : '❌'} |

## Scope
**Included**: ${spec.scope?.in?.join(', ') || 'Not specified'}
**Excluded**: ${spec.scope?.out?.join(', ') || 'Not specified'}

## Required Artifacts
${
  mode === 'feature'
    ? `
- [ ] **Contracts updated** (OpenAPI/GraphQL/Proto)
- [ ] **Feature flag** + migration plan
- [ ] **Blast radius** documented
- [ ] **Rollback SLO** defined
`
    : mode === 'refactor'
      ? `
- [ ] **Codemod script** created
- [ ] **Semantic diff** reviewed
- [ ] **No public API changes**
- [ ] **Golden frames** preserved
`
      : `
- [ ] **Failing test** reproduces bug
- [ ] **Root cause** documented
- [ ] **Guard test** added
- [ ] **Minimal diff** applied
`
}

## Checklists
Copy and paste these into your PR description:

### ${mode.charAt(0).toUpperCase() + mode.slice(1)} Checklist
${
  mode === 'feature'
    ? `
* [ ] Contracts updated first (OpenAPI/GraphQL/Proto) and verified
* [ ] Unit + contract + integration + E2E smoke written before impl
* [ ] Feature flag + reversible migration + rollback plan
* [ ] Observability: logs/metrics/traces named & asserted
* [ ] A11y/perf budgets met
`
    : mode === 'refactor'
      ? `
* [ ] Codemod added in \`docs/${id}/codemod/\` with dry-run & apply
* [ ] No public API change; golden frames unchanged
* [ ] Mutation score ≥ baseline; coverage not reduced
* [ ] No duplicate/"enhanced-*.ts" files
`
      : `
* [ ] Minimal failing test reproduces bug
* [ ] Root cause noted; guard test added
* [ ] Risk tier confirmed; scope confined to \`scope.in\`
`
}

## Documentation
- [CAWS Developer Guide](docs/caws-developer-guide.md)
- [Feature Plan](docs/${id}/feature.plan.md)
- [Test Plan](docs/${id}/test-plan.md)
${mode === 'refactor' ? `- [Codemod](docs/${id}/codemod/refactor.ts)` : ''}

---
*Generated by CAWS PR Bot | ${new Date().toISOString().split('T')[0]}*
`;

  return comment;
}

// CLI usage
if (require.main === module) {
  const comment = generatePRComment();
  console.log(comment);
}

module.exports = { generatePRComment };
